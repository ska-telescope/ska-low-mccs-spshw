display: ":0"
xauthority: "~/.Xauthority"

enabled: true

system: SW-infrastructure
subsystem: low-mccs-spshw 
telescope: SKA-low

labels:
  app: ska-low-mccs-spshw

global:
  sub-system:
    ska-tango-base:
      enabled: false
    taranta:
      enabled: false
    archiver:
      enabled: false
  minikube: true
  tango_host: databaseds-tango-base-test:10000

livenessProbe:
  initialDelaySeconds: 0
  periodSeconds: 10
  timeoutSeconds: 3
  successThreshold: 1
  failureThreshold: 3
readinessProbe:
  initialDelaySeconds: 0
  periodSeconds: 10
  timeoutSeconds: 3
  successThreshold: 1
  failureThreshold: 3

ska-taranta:
  enabled: true
  ingress:
    enabled: true
    nginx: true
    hostname: k8s.stfc.skao.int
  tangogql:
    replicas: 1
    resources:
      requests:
        cpu: 600m  # 600m = 0.6 CPU
        memory: 512Mi  # 512Mi = 0.5 GB mem

ska-taranta-dashboard:
  ingress:
    enabled: true
    nginx: true
    hostname: test-taranta.k8s.stfc.skao.int

ska-taranta-auth:
  ingress:
    enabled: true
    nginx: true
    hostname: test-taranta.k8s.stfc.skao.int

# Jupyterhub is a large image and you may experience a kubelet timeout MCCS-1238.
# Error: UPGRADE FAILED: pre-upgrade hooks failed: timed out waiting for the condition
# You can perform a manual pull using: 
# minikube image pull registry.gitlab.com/ska-telescope/sdi/ska-cicd-deploy-low-itf/tango-notebook:0.1.1
# Jupyter has ingress meaning you can access using ${MINIKUBE_IP}/jupyterhub/
# e.g 192.168.49.2/jupyterhub/
jupyterhub:
  hub:
    baseUrl: /jupyterhub
  ingress:
    pathType: Prefix
    enabled: true
    annotations:
      kubernetes.io/ingress.class: nginx
  singleuser:
    image:
      name: registry.gitlab.com/ska-telescope/sdi/ska-cicd-deploy-low-itf/tango-notebook
      tag: 0.1.1
    extraEnv:
      TANGO_HOST: "databaseds-tango-base-test.ska-low-mccs-spshw:10000"
  proxy:
    service:
      type: ClusterIP

# The following values overwrite the default values in the postgresql dependency.
# See https://artifacthub.io/packages/helm/bitnami/postgresql
postgresql:
  commonLabels:
    app: ska-low-mccs-spshw

  enabled: true

  image:
    debug: true

  auth:
    postgresPassword: "secretpassword"

  primary:
    service:
      type: LoadBalancer

    initdb:
      scriptsConfigMap: ska-low-mccs-spshw-initdb
      user: "postgres"

    persistence:
      enabled: true
      ## @param primary.persistence.mountPath The path the volume will be mounted at
      ## Note: useful when using custom PostgreSQL images
      ##
      mountPath: /bitnami/postgresql
      ## @param primary.persistence.storageClass PVC Storage Class for PostgreSQL Primary data volume
      ## If defined, storageClassName: <storageClass>
      ## If set to "-", storageClassName: "", which disables dynamic provisioning
      ## If undefined (the default) or set to null, no storageClassName spec is
      ##   set, choosing the default provisioner.  (gp2 on AWS, standard on
      ##   GKE, AWS & OpenStack)
      ##
      storageClass: "nfss1"
      ## @param primary.persistence.accessModes PVC Access Mode for PostgreSQL volume
      ##
      accessModes:
        - ReadWriteMany
      ## @param primary.persistence.size PVC Storage Request for PostgreSQL volume
      ##
      size: 12Gi

# The following values are used by the templates in this chart for create pgAdmin and initialising the database
pgadmin4:
  enabled: true

  replicaCount: 1

  service:
    type: LoadBalancer
    port: 80

  image:
    registry: docker.io
    repository: dpage/pgadmin4
    tag: "6.10"
    pullPolicy: IfNotPresent

  env:
    # can be email or nickname
    email: mccs@skao.int
    password: secretpassword

  serverDefinitions:
    ## If true, server definitions will be created
    ##
    enabled: true

    servers:
     firstServer:
       Name: "MCCS"
       Group: "Servers"
       Port: 5432
       Username: "postgres"
       Host: "localhost"
       SSLMode: "prefer"
       MaintenanceDB: "postgres"

  resources: {}

  containerPorts:
    http: 80

  ingress:
    enabled: true

initDbName: ska-low-mccs-spshw-initdb # must be equals to postgresql.primary.initdb.scriptsConfigMap
initDbBasePath: data/
initDbScripts:
- create_tables.sql

ska-low-mccs-spshw:
  simulators:
    subracks:
      1:
        host: subrack-simulator-1

  deviceServers:  # e.g....
    stations:
      instances:
        1:
          cabinet_network_address: 10.0.0.0
          subracks: [1]
          tpms: [1]
    stationcalibrators:
      instances:
        1:
          field_station: 1
          calibration_store: 1
    calibrationstores:
      instances:
        1:
          logging_level: 5
    mockfieldstations:
      instances:
        1:
          logging_level: 5
    tpms:
      instances:
        1:
          host: 10.0.10.201
          port: 10000
          version: tpm_v1_6
          subrack: "1"
          subrack_bay: 1
      logging_level_default: 5
      simulation_config: 1
      test_config: 1
      resources:
        requests:
          memory: 512Mi
