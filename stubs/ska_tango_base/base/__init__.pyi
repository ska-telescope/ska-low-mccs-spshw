import logging
import enum
from typing import Any, Optional, Callable, Union, Tuple, Type

from tango.server import Device

from ska_tango_base.base.op_state_model import OpStateModel
from ska_tango_base.commands import CompletionCommand, ResultCode, ResponseCommand, StateModelCommand, BaseCommand
from ska_tango_base.control_model import PowerMode

class BaseComponentManager:
    def __init__(
        self: BaseComponentManager,
        op_state_model: OpStateModel | None,
        *args: Any,
        **kwargs: Any,
    ): self._queue_manager: QueueManager
    def start_communicating(self: BaseComponentManager) -> None: ...
    def stop_communicating(self: BaseComponentManager) -> None: ...
    @property
    def is_communicating(self: BaseComponentManager) -> bool: ...
    @property
    def power_mode(self: BaseComponentManager) -> Optional[PowerMode]: ...
    @property
    def faulty(self: BaseComponentManager) -> Optional[bool]: ...
    def off(self: BaseComponentManager) -> ResultCode | None: ...
    def standby(self: BaseComponentManager) -> ResultCode | None: ...
    def on(self: BaseComponentManager) -> ResultCode | None: ...
    def reset(self: BaseComponentManager) -> ResultCode | None: ...
    def component_power_mode_changed(
        self: BaseComponentManager, power_mode: PowerMode
    ) -> None: ...
    def component_fault(self: BaseComponentManager) -> None: ...
    def enqueue(self: BaseComponentManager, task: BaseCommand, argin: Optional[Any] = None) -> Tuple[str, ResultCode]: ...


class TaskResult:
    def __init__(self: TaskResult, result_code: ResultCode, task_result: str, unique_id: str) -> None: ...

class TaskState(enum.IntEnum): ...

class QueueManager:
    def __init__(
        self: QueueManager,
        max_queue_size: int,
        queue_fetch_timeout: float,
        num_workers: int,
        logger: Optional[logging.Logger],
        push_change_event: Optional[Callable],
    ): self._task_result: Tuple[str, str, str]
    @property
    def queue_full(self: QueueManager) -> bool: ...
    @property
    def task_result(self: QueueManager) -> Union[Tuple[str, str, str], Tuple[()]]: ...
    @property
    def task_ids_in_queue(self: QueueManager) -> Tuple[str,]: ...
    @property
    def tasks_in_queue(self: QueueManager) -> Tuple[str,]: ...
    @property
    def task_status(self: QueueManager) -> Tuple[str,]: ...
    @property
    def task_progress(self: QueueManager) -> Tuple[str,]: ...
    def enqueue_task(self: QueueManager, task: BaseCommand, argin: Optional[Any]) -> Tuple[str, ResultCode]: ...
    def result_callback(self: QueueManager, task_result: TaskResult) -> None: ...
    def update_task_state_callback(self: QueueManager, unique_id: str, status: str) -> None: ...
    def update_progress_callback(self: QueueManager) -> None: ...
    def _on_property_change(self: QueueManager, property_name: str, property_value: Any) -> None: ...
    def abort_tasks(self: QueueManager) -> None: ...
    def resume_tasks(self: QueueManager) -> None: ...
    def stop_tasks(self: QueueManager) -> None: ...
    @property
    def is_aborting(self: QueueManager) -> bool: ...
    @classmethod
    def generate_unique_id(cls: Type[QueueManager], task_name: Any) -> str: ...
    def get_task_state(self: QueueManager, unique_id: str) -> TaskState: ...
    def _log_message(self: QueueManager, message: str, level: str) -> None: ...
    def __len__(self: QueueManager) -> int: ...
    def __bool__(self: QueueManager) -> bool: ...

class SKABaseDevice(Device):
    def _init_state_model(self: SKABaseDevice) -> None: ...
    def _init_logging(self: SKABaseDevice) -> None: ...
    def init_device(self: SKABaseDevice) -> None: ...


    class InitCommand(ResponseCommand, CompletionCommand):
        def __init__(
            self: SKABaseDevice.InitCommand,
            target: Any,
            op_state_model: OpStateModel,
            logger: Optional[logging.Logger]=None
        ) -> None:
            self.logger = logger
            ...

        def do(  # type: ignore[override]
            self: SKABaseDevice.InitCommand
        ) -> tuple[ResultCode, str]: ...

    class OnCommand(StateModelCommand, ResponseCommand):
        def __init__(self: SKABaseDevice.OnCommand, target: object, op_state_model: OpStateModel, logger: Optional[logging.Logger]=None) -> None: ...
        def do(  # type: ignore[override]
            self: SKABaseDevice.OnCommand
        ) -> tuple[ResultCode, str]: ...

    class OffCommand(StateModelCommand, ResponseCommand):
        def __init__(
            self: SKABaseDevice.OffCommand,
            target: object,
            op_state_model: OpStateModel,
            logger: Optional[logging.Logger]=None
        ) -> None:
            self.logger = logger
            ...

        def do(  # type: ignore[override]
            self: SKABaseDevice.OffCommand
        ) -> tuple[ResultCode, str]: ...

    def is_On_allowed(self: SKABaseDevice) -> bool: ...
    def On(self: SKABaseDevice) -> tuple[list[ResultCode], list[Optional[str]]]: ...
